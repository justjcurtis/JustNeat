var Neat=function(){"use strict";const t=(t=6)=>{for(var e=0,n=0;n<t;n++)e+=Math.random();return e/t},e=(t,e)=>t+Math.random()*(e-t+1);var n={gaussianRand:t,randomInt:(t,n)=>Math.floor(e(t,n)),randomRange:e,randomStd0:()=>2*(t()-.5),sigmoid:t=>1/(1+Math.exp(-t)),erf:t=>{var e=t<0?-1:1,n=1/(1+.3275911*(t=Math.abs(t)));return e*(1-((((1.061405429*n-1.453152027)*n+1.421413741)*n-.284496736)*n+.254829592)*n*Math.exp(-(t**2)))},softPlus:t=>Math.log(1+Math.exp(t))};const{sigmoid:o,erf:s,softPlus:i}=n;var h={aNm:{id:0,sig:1,relu:2,bin:3,bipol:4,tanh:5,swish:6,invert:7,bipolSig:8,hardTanh:9,arcTan:10,softSign:11,sinc:12,sin:13,gaussian:14,isru:15,gelu:16,bentId:17,softPlus:18,mish:19,sqnl:20,erf:21,elu:22,selu:23},aFn:[t=>t,t=>o(t),t=>Math.max(t,0),t=>t<0?0:1,t=>t<0?-1:1,t=>Math.tanh(t),t=>Math.max(.1*t,0),t=>t*o(t),t=>1-t,t=>2*o(t)-1,t=>Math.max(-1,Math.min(1,t)),t=>Math.atan(t),t=>t/(1+Math.abs(t)),t=>0==t?1:Math.sin(t)/t,t=>Math.sin(t),t=>Math.exp(-(t**2)),t=>t/Math.sqrt(1+t**2),t=>t/2*(1+s(t/Math.SQRT2)),t=>(Math.sqrt(t**2+1)-1)/2+t,t=>i(t),t=>t*Math.tanh(i(t)),t=>t>2?1:t<-2?-1:t+t**2/4,t=>s(t),t=>t>0?t:Math.expm1(t),t=>1.0507*(t>0?t:1.67326*Math.expm1(t))]};var r={unknown:0,input:1,hidden:2,output:3};const{aNm:c}=h;class a{constructor(t,e,n){this.id=t,this.bias=n,this.type=e,this.layer=e==r.input?0:null,this.activation=e==r.hidden?c.tanh:c.id}static Equal(t,e){return t.id==e.id}static FromJson(t){const e=JSON.parse(t),n=new a(e.id,e.type,e.bias);return n.layer=e.layer,n.activation=e.activation,n}copy(){const t=new a(this.id,this.type,this.bias);return t.activation=this.activation,t.layer=this.layer,t}toJson(){return JSON.stringify({id:this.id,type:this.type,bias:this.bias,layer:this.layer,activation:this.activation})}}var l=a;class p{constructor(t,e,n,o,s=!1,i=!0){this.inNode=t,this.outNode=e,this.id=`${t},${e}`,this.weight=n,this.recurrent=s,this.enabled=i,this.outputCache=0,this.innov=o}static Equal(t,e){return t.innov==e.innov}static FromJson(t){const e=JSON.parse(t);return new p(e.inNode,e.outNode,e.weight,e.innov,e.recurrent,e.enabled)}copy(){return new p(this.inNode,this.outNode,this.weight,this.innov,this.recurrent,this.enabled)}toJson(){return JSON.stringify({inNode:this.inNode,outNode:this.outNode,id:this.id,weight:this.weight,enabled:this.enabled,recurrent:this.recurrent,outputCache:this.outputCache,innov:this.innov})}}var d=p;const{randomInt:u}=n;var g={rouletteSelectClientArray:t=>{t.sort(((t,e)=>t.score-e.score));const e=t.reduce(((t,e)=>t+e.score),0),n=Math.random()*e;let o=0;for(let e=0;e<t.length;e++){if(n<t[e].score+o)return t[e];o+=t[e].score}return t[t.length-1]},normalizeArray:t=>{const e=t.reduce(((t,e)=>t+e),0);return 0==e?t.slice(0):t.slice(0).map((t=>t/e))},getRandomElement:t=>t[u(0,t.length-1)]};const{getRandomElement:m}=g,{randomRange:f,randomStd0:y}=n,{aNm:C}=h;class v{constructor(t=[],e=[],n=null){this.species=n,this.nodes=t,this.nodeMap={},this.layers=[],this.connections=e,this.connectionMap={},e.length>0&&this.buildGenomeMap(),this.constructLayers()}buildGenomeMap(){this.connectionMap={};for(let t=0;t<this.connections.length;t++){const e=this.connections[t];this.connectionMap[e.id]=t}this.nodeMap={};for(let t=0;t<this.nodes.length;t++){const e=this.nodes[t];this.nodeMap[e.id]=t}}static FromJson(t){const e=JSON.parse(t),n=e.nodes.map((t=>l.FromJson(t))),o=e.connections.map((t=>d.FromJson(t)));return new v(n,o,e.species)}copy(){return new v(this.nodes.map((t=>t.copy())),this.connections.map((t=>t.copy())),this.species)}toJson(){const t=this.nodes.map((t=>t.toJson())),e=this.connections.map((t=>t.toJson()));return JSON.stringify({nodes:t,connections:e,species:this.species})}getGraph(){const t={};for(let e=0;e<this.nodes.length;e++){let n=this.nodes[e];t[n.id]={children:[],parents:[],value:0,node:n}}for(let e=0;e<this.connections.length;e++){const n=this.connections[e];t[n.inNode].children.push(n),t[n.outNode].parents.push(n)}return t}getLongestPathToInput(t,e,n={}){if(n[t]=!0,e[t].node.type==r.input)return 0;const o=e[t].parents;if(0==o.length)return;const s=[];for(let t=0;t<o.length;t++)n[o[t].inNode]||o[t].recurrent||s.push(this.getLongestPathToInput(o[t].inNode,e,n)+1);return Math.max(...s)}constructLayers(){this.layers=[];const t={},e=this.getGraph(),n=[],o=[];for(let s=0;s<this.nodes.length;s++){if(this.nodes[s].type==r.input){n.push(this.nodes[s]);continue}if(this.nodes[s].type==r.output){o.push(this.nodes[s]);continue}const i=this.getLongestPathToInput(this.nodes[s].id,e);null==t[i]&&(t[i]=[]),this.nodes[s].layer=i,t[i].push(this.nodes[s])}const s=Object.keys(t).length+1;for(let t=0;t<o.length;t++)o[t].layer=s;this.layers=[n,...Object.values(t),o];for(let t=0;t<this.layers.length;t++)this.layers[t].sort(((t,e)=>t.id-e.id));for(let t=0;t<this.connections.length;t++){const e=this.connections[t],n=this.nodes[this.nodeMap[e.inNode]],o=this.nodes[this.nodeMap[e.outNode]];n.layer==o.layer?e.enabled=!1:n.layer>o.layer?e.recurrent=!0:e.recurrent&&(e.recurrent=!1)}}simplify(t){this.connections.length<1||(Math.random()<t.probs.disableConnectionChance&&this.mutateDeleteConnection(),Math.random()<t.probs.addNodeChance&&this.mutateDeleteNode(t),this.mutate(t))}augment(t){Math.random()<t.probs.addConnectionChance&&this.mutateConnection(t),this.connections.length<1||(Math.random()<t.probs.addNodeChance&&this.mutateInterpose(t),Math.random()<t.probs.disableConnectionChance&&this.mutateDisableConnection(),this.mutate(t))}mutate(t){Math.random()<t.probs.randomActivationChance&&this.mutateActivation(t.allowedActivations),Math.random()<t.probs.biasMutationChance&&(Math.random()<t.probs.biasShiftChance?this.mutateBiasShift(t.hyper.biasShiftStrength):this.mutateBiasRandom(t)),this.connections.length<1||Math.random()<t.probs.weightMutationChance&&(Math.random()<t.probs.weightShiftChance?this.mutateWeightShift(t.hyper.weightShiftStrength):this.mutateWeightRandom(t))}deleteConnection(t){const e=this.connectionMap[t];this.connections.splice(e,1),delete this.connectionMap[t],this.buildGenomeMap()}deleteNode(t){const e=this.nodeMap[t];this.nodes.splice(e,1),delete this.nodeMap[t],this.buildGenomeMap()}mutateDeleteConnection(){const t=this.getGraph(),e=m(this.connections);if(t[e.outNode].node.type==r.hidden&&1==t[e.outNode].parents.length){const n=this.nodeMap[e.outNode];for(let n=0;n<t[e.outNode].children.length;n++)this.deleteConnection(t[e.outNode].children[n].id);this.nodes.splice(n,1),delete this.nodeMap[e.outNode]}if(t[e.inNode].node.type==r.hidden&&1==t[e.inNode].children.length){const n=this.nodeMap[e.inNode];for(let n=0;n<t[e.inNode].parents.length;n++)this.deleteConnection(t[e.inNode].parents[n].id);this.nodes.splice(n,1),delete this.nodeMap[e.inNode]}this.deleteConnection(e.id),this.buildGenomeMap(),this.constructLayers()}mutateDeleteNode(t){const e=this.getGraph(),n=this.nodes.filter((t=>t.type==r.hidden));if(!(n.length<1))for(let o=0;o<20;o++){const o=m(n);if(e[o.id].parents.length<=1||e[o.id].parents.length<=1){if(1==e[o.id].parents.length){const n=e[e[o.id].parents[0].inNode].node;for(let s=0;s<e[o.id].children.length;s++){const i=e[e[o.id].children[s].outNode].node,h=e[o.id].parents[0].weight*e[o.id].children[s].weight;t.addConnection(this,n,i,h)}}else if(1==e[o.id].children.length){const n=e[e[o.id].children[0].inNode].node;for(let s=0;s<e[o.id].parents.length;s++){const i=e[e[o.id].parents[s].outNode].node,h=e[o.id].parents[s].weight*e[o.id].children[0].weight;t.addConnection(this,i,n,h)}}for(let t=0;t<e[o.id].parents.length;t++)this.deleteConnection(e[o.id].parents[t].id);for(let t=0;t<e[o.id].children.length;t++)this.deleteConnection(e[o.id].children[t].id);this.deleteNode(o.id),this.constructLayers();break}}}mutateActivation(t){if(t.length<1)return;const e=m(t);m(this.nodes.filter((t=>t.type!=r.input))).activation=C[e]}mutateBiasShift(t=.3){m(this.nodes).bias*=y()*t,this.g=null}mutateBiasRandom(t){m(this.nodes).bias=f(t.hyper.minBias,t.hyper.maxBias),this.g=null}mutateConnection(t){for(let e=0;e<20;e++){const e=m(this.nodes),n=m(this.nodes);if(t.addConnection(this,e,n)){this.g=null;break}}this.constructLayers()}mutateInterpose(t){for(let e=0;e<20;e++){const e=m(this.connections);if(!e.recurrent&&e.enabled){t.interposeConnection(this,e),this.g=null;break}}this.constructLayers()}mutateWeightShift(t=.3){m(this.connections).weight*=y()*t,this.g=null}mutateWeightRandom(t){m(this.connections).weight=f(t.hyper.minWeight,t.hyper.maxWeight),this.g=null}mutateDisableConnection(){m(this.connections).enabled=!1,this.g=null,this.constructLayers()}}var M=v;const{aFn:P}=h;var b=class{constructor(t){this.genome=t,this.score=-1/0,this.genomeCost=0}getInputValue(t,e){let n=0;for(let o=0;o<e[t.id].parents.length;o++){const s=e[t.id].parents[o];s.enabled&&(s.recurrent?n+=s.outputCache:n+=e[s.inNode].value*s.weight)}return n}setRecurrentOutputCaches(t){const e=this.genome.connections.filter((t=>t.recurrent));for(let n=0;n<e.length;n++){const o=e[n];o.outputCache=t[o.inNode].value}}getOutput(t){return this.genome.layers[this.genome.layers.length-1].map((e=>t[e.id].value))}feedForward(t,e){const n=this.genome.layers[0];for(let o=0;o<n.length;o++){const s=n[o];let i=t[o]+this.getInputValue(s,e);e[s.id].value=i}for(let t=1;t<this.genome.layers.length;t++){const n=this.genome.layers[t];for(let t=0;t<n.length;t++){const o=n[t],s=this.getInputValue(o,e);e[o.id].value=P[o.activation](s+o.bias)}}return this.setRecurrentOutputCaches(e),this.getOutput(e)}predict(t){if(t.length!=this.genome.layers[0].length)throw`Expected input size ${this.genome.layers[0].length} but received ${t.length}`;const e=this.genome.getGraph();return this.feedForward(t,e)}};var N={lNm:{mse:0},lFn:[t=>{let e=0;for(let n=0;n<t.length;n++){let o=0;for(let e=0;e<t[n][0].length;e++){const s=t[n][0][e]-t[n][1][e];o+=Math.pow(s,2)}o/=t[n][0].length,e+=o}return e/t.length}]};const{randomRange:S}=n,{rouletteSelectClientArray:w}=g,{aNm:x}=h,{lFn:F,lNm:A}=N,J={c1:1,c2:1,c3:.4,weightShiftStrength:.2,biasShiftStrength:.2,threshold:10,speciesTarget:50,initialMutation:1,cullRate:.5,minWeight:-100,maxWeight:100,minBias:-100,maxBias:100,elitism:.01,dropoff:15,dropRate:0,cloneRate:.25,complexityThreshold:30,complexityFloorDelay:10,fitnessPlatauThreshold:10,connectionCost:.1,nodeCost:.2},T={weightMutationChance:.8,weightShiftChance:.9,biasMutationChance:.8,biasShiftChance:.9,addConnectionChance:.05,addRecurrentChance:.5,reEnableConnectionChance:.25,disableConnectionChance:.05,addNodeChance:.025,deleteConnectionChance:.05,deleteNodeChance:.025,randomActivationChance:.05},k={maxPop:1e3,recurrent:!1,outputActivation:"tanh",hiddenActivation:"tanh",allowedActivations:["id","sig","tanh","relu","bin","gelu","softPlus","invert","softSign","bipolSig"],lossFn:"mse",hyper:{},probs:{}};class R{constructor(t,e,n,o=!1){n={...k,...n},this.inputs=t,this.outputs=e,this.outputActivation=n.outputActivation,this.hiddenActivation=n.hiddenActivation,this.allowedActivations=n.allowedActivations,this.lossFn=n.lossFn,this.maxPop=n.maxPop,this.pop=[],this.connectionPool={},this.connections=[],this.replacePool={},this.currentConnections=0,this.nodePool=[],this.mandatoryNodes=[],this.hyper={...J,...n.hyper},this.probs={...T,...n.probs},n.recurrent||(this.probs.addRecurrentChance=0),this.prevSpecScores={},this.dropoffTracker={},this.nextPruneComplexity=0,this.pruning=!1,this.lastMCP=0,this.mcpFloorCount=0,this.lastPopFitness=0,this.currentPopFitness=0,this.fitnessPlatauCount=0,o||this.reset()}static FromJson(t){const e=JSON.parse(t),n={maxPop:e.maxPop,recurrent:0==e.hyper.addRecurrentChance,outputActivation:e.outputActivation,hiddenActivation:e.hiddenActivation,allowedActivations:e.allowedActivations,lossFn:e.lossFn,hyper:e.hyper,probs:e.probs},o=new R(e.inputs,e.outputs,n,!0),s={};for(let t=0;t<e.replacePool.length;t++)s[e.replacePool[t][0]]=l.FromJson(e.replacePool[t][1]);return o.replacePool=s,o.pop=e.pop.map((t=>new b(M.FromJson(t)))),o.nodePool=e.nodePool.map((t=>l.FromJson(t))),o.mandatoryNodes=e.mandatoryNodes.map((t=>l.FromJson(t))),o.connections=e.connections.map((t=>d.FromJson(t))),o.connectionPool=e.connectionPool,o.nextPruneComplexity=e.nextPruneComplexity,o.pruning=e.pruning,o.lastMCP=e.lastMCP,o.mcpFloorCount=e.mcpFloorCount,o.lastPopFitness=e.lastPopFitness,o.currentPopFitness=e.currentPopFitness,o.fitnessPlatauCount=e.fitnessPlatauCount,o.prevSpecScores=e.prevSpecScores,o.dropoffTracker=e.dropoffTracker,o.currentConnections=e.currentConnections,o}toJson(){return JSON.stringify({nextPruneComplexity:this.nextPruneComplexity,pruning:this.pruning,lastMCP:this.lastMCP,mcpFloorCount:this.mcpFloorCount,lastPopFitness:this.lastPopFitness,currentPopFitness:this.currentPopFitness,fitnessPlatauCount:this.fitnessPlatauCount,hyper:this.hyper,probs:this.probs,connectionPool:this.connectionPool,connections:this.connections.map((t=>t.toJson())),nodePool:this.nodePool.map((t=>t.toJson())),replacePool:Object.entries(this.replacePool).map((t=>[t[0],t[1].toJson()])),pop:this.pop.map((t=>t.genome.toJson())),prevSpecScores:this.prevSpecScores,dropoffTracker:this.dropoffTracker,mandatoryNodes:this.mandatoryNodes.map((t=>t.toJson())),currentConnections:this.currentConnections,inputs:this.inputs,outputs:this.outputs,outputActivation:this.outputActivation,hiddenActivation:this.hiddenActivation,allowedActivations:this.allowedActivations,lossFn:this.lossFn,maxPop:this.maxPop})}reset(){const t=[];for(let e=0;e<this.outputs;e++){const n=new l(e+this.inputs,r.output,S(this.hyper.minBias,this.hyper.maxBias));n.activation=x[this.outputActivation],t.push(n)}const e=[];this.connections=[],this.connectionPool={},this.currentConnections=0,this.replacePool={},this.prevSpecScores={},this.dropoffTracker={};for(let n=0;n<this.inputs;n++){const o=new l(n,r.input,S(this.hyper.minBias,this.hyper.maxBias));e.push(o);for(let e=0;e<t.length;e++)this.connectionPool[`${o.id},${t[e].id}`]=this.currentConnections,this.connections.push(new d(o.id,t[e].id,S(this.hyper.minBias,this.hyper.maxBias),this.currentConnections)),this.currentConnections++}this.nodePool=[...e,...t],this.mandatoryNodes=this.nodePool.slice(0),this.pop=[];for(let t=0;t<this.maxPop;t++){const t=this.blankGenome();for(let e=0;e<this.hyper.initialMutation;e++)t.augment(this);this.pop.push(new b(t))}const n=this.mcp();this.nextPruneComplexity=n+this.hyper.complexityThreshold,this.pruning=!1,this.lastMCP=0,this.mcpFloorCount=0,this.lastPopFitness=0,this.currentPopFitness=0,this.fitnessPlatauCount=0}getInnovationId(t,e){const n=`${t},${e}`;return this.connectionPool[n]?this.connectionPool[n]:(this.connectionPool[n]=this.currentConnections,this.currentConnections++,this.currentConnections-1)}newNode(t){const e=new l(this.nodePool.length,t,S(this.hyper.minBias,this.hyper.maxBias));for(let t=0;t<this.nodePool.length;t++){const n=this.nodePool[t];if(!(n.type<e.type)){if(n.type==e.type){if(n.id<e.id)continue;this.nodePool.splice(t,0,e);break}this.nodePool.splice(t,0,e);break}}return e}blankGenome(){const t=this.mandatoryNodes.slice(0);for(let e=0;e<t.length;e++)t[e]=t[e].copy(),t[e].bias=S(this.hyper.minBias,this.hyper.maxBias);const e=this.connections.slice(0);for(let t=0;t<e.length;t++)e[t]=e[t].copy(),e[t].weight=S(this.hyper.minWeight,this.hyper.maxWeight);return new M(t,e)}addConnection(t,e,n,o){if(e.layer==n.layer)return!1;if(e.layer>n.layer&&Math.random()>=this.probs.addRecurrentChance)return!1;const s=`${e.id},${n.id}`;if(null!=t.connectionMap[s])return!(Math.random()>=this.hyper.reEnableConnectionChance)&&(t.connections[t.connectionMap[s]].enabled=!0,!0);const i=null==o?S(this.hyper.minWeight,this.hyper.maxWeight):o,h=this.getInnovationId(e.id,n.id),r=new d(e.id,n.id,i,h);return t.connectionMap[r.id]=t.connections.length,t.connections.push(r),!0}interposeConnection(t,e){let n;null!=this.replacePool[e.id]?n=this.replacePool[e.id].copy():(n=this.newNode(r.hidden),n.activation=x[this.hiddenActivation],this.replacePool[e.id]=n);const o=this.getInnovationId(e.inNode,n.id),s=this.getInnovationId(n.id,e.outNode),i=new d(e.inNode,n.id,1,o),h=new d(n.id,e.outNode,e.weight,s),c=t.connectionMap[e.id];t.connections[c].enabled=!1,t.connectionMap[i.id]=t.connections.length,t.connections.push(i),t.connectionMap[h.id]=t.connections.length,t.connections.push(h),t.nodeMap[n.id]=t.nodes.length,n.layer=t.nodes[t.nodeMap[e.inNode]]+1,t.nodes.push(n)}mcp(){return this.pop.reduce(((t,e)=>t+(e.genome.nodes.length+e.genome.connections.length)),0)/this.pop.length}dist(t,e){let n=0,o=0;if((t.connections.length>0?t.connections.slice(-1)[0].innov:0)<(e.connections.length>0?e.connections.slice(-1)[0].innov:0)){const n=t;t=e,e=n}let s=0,i=0,h=0;for(;n<t.connections.length&&o<e.connections.length;){const r=t.connections[n],c=e.connections[o];r.innov!=c.innov?r.innov>c.innov?(s++,o++):(s++,n++):(i++,h+=Math.abs(r.weight-c.weight),n++,o++)}i>0&&(h/=i);let r=t.connections.length-n,c=Math.max(t.connections.length,e.connections.length);return c<20&&(c=1),this.hyper.c1*s/c+this.hyper.c2*r/c+this.hyper.c3*h}crossover(t,e){let n=0,o=0;const s=[],i=Object.fromEntries(this.mandatoryNodes.map((t=>[t.id,!0])));for(;n<t.connections.length&&o<e.connections.length;){const h=t.connections[n],r=e.connections[o];h.innov!=r.innov?h.innov<r.innov?(s.push(h),i[h.inNode]=!0,i[h.outNode]=!0,n++):o++:(Math.random()<.5?(s.push(h.copy()),i[h.inNode]=!0,i[h.outNode]=!0):(s.push(r.copy()),i[r.inNode]=!0,i[r.outNode]=!0),n++,o++)}for(;n<t.connections.length;){const e=t.connections[n];s.push(e.copy()),i[e.inNode]=!0,i[e.outNode]=!0,n++}const h=[],r=Object.keys(i);for(let n=0;n<r.length;n++){const o=r[n],s=t.nodeMap[o],i=e.nodeMap[o];if(null==s)h.push(e.nodes[i].copy());else{if(null!=i){Math.random()<.5?h.push(t.nodes[s].copy()):h.push(e.nodes[i].copy());continue}h.push(t.nodes[s].copy())}}return new M(h,s,t.species)}speciate(){let t={},e=0;for(let n=0;n<this.pop.length;n++){const o=this.pop[n];null!=o.genome.species&&(null==t[o.genome.species]&&(e<o.genome.species&&(e=o.genome.species),t[o.genome.species]=[o]))}t:for(let n=0;n<this.pop.length;n++){const o=Object.keys(t);for(let e=0;e<o.length;e++){const s=o[e];if(this.pop[n].genome==t[s][0].genome)continue;if(!(this.dist(this.pop[n].genome,t[s][0].genome)>this.hyper.threshold)){this.pop[n].genome.species=s,t[s].push(this.pop[n]);continue t}}e++,this.pop[n].genome.species=e,t[e]=[this.pop[n]]}t=Object.values(t);for(let e=0;e<t.length;e++){t[e].sort(((t,e)=>e.score-e.genomeCost-(t.score-t.genomeCost)));for(let n=0;n<t[e].length;n++)t[e][n].genome.species=e}return t}cull(t){for(let e=0;e<t.length;e++){const n=Math.max(Math.floor((1-this.hyper.cullRate)*t[e].length),1);t[e]=t[e].slice(0,n)}return t=t.filter((t=>t.length>0))}breed(t){const e=[],n=t.map((t=>t.map((e=>e.score/t.length)))),o=n.map((t=>t.reduce(((t,e)=>t+e),0)/t.length));if(Math.random()<this.hyper.dropRate){const t=o.indexOf(Math.min(...o));o[t]=0,null!=this.dropoffTracker[t]&&delete this.dropoffTracker[t],null!=this.prevSpecScores[t]&&delete this.prevSpecScores[t]}const s=n.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e),0)),0)/n.reduce(((t,e)=>t+e.length),0);this.currentPopFitness=s;for(let t=0;t<o.length;t++)if(null!=this.prevSpecScores[t]){if(o[t]<=this.prevSpecScores[t])this.dropoffTracker[t]||(this.dropoffTracker[t]=0),this.dropoffTracker[t]++,this.dropoffTracker[t]>=this.hyper.dropoff&&(o[t]=0,delete this.dropoffTracker[t],delete this.prevSpecScores[t]);else if(null!=this.dropoffTracker[t]){delete this.dropoffTracker[t],delete this.prevSpecScores[t];continue}this.prevSpecScores[t]=o[t]}else this.prevSpecScores[t]=o[t];for(let n=0;n<t.length;n++){let i=Math.round(o[n]/s*t[n].length);for(;i>0;){if(Math.random()<this.hyper.cloneRate){const o=w(t[n]);e.push(new b(o.genome.copy()))}else{const o=[w(t[n]),w(t[n])];o.sort(((t,e)=>e.score-t.score));const s=this.crossover(o[0].genome,o[1].genome);e.push(new b(s))}i--}}return e}mutate(){if(this.pruning)for(let t=0;t<this.pop.length;t++)this.pop[t].genome.simplify(this);else for(let t=0;t<this.pop.length;t++)this.pop[t].genome.augment(this)}populateGenomeCosts(){if(0!=this.hyper.connectionCost||0!=this.hyper.nodeCost)for(let t=0;t<this.pop.length;t++){const e=this.pop[t];e.genomeCost=e.genome.connections.length*this.hyper.connectionCost+e.genome.nodes.length*this.hyper.nodeCost}}evolve(){this.pop.sort(((t,e)=>e.score-e.genomeCost-(t.score-t.genomeCost))),this.populateGenomeCosts();let t=this.speciate();const e=this.pop.slice(0,Math.ceil(this.pop.length*this.hyper.elitism)).map((t=>new b(t.genome.copy())));if(t.length>this.hyper.speciesTarget&&this.hyper.threshold++,t.length<this.hyper.speciesTarget&&this.hyper.threshold--,t=this.cull(t),this.pop=this.breed(t),this.pop.length+e.length<this.maxPop){const t=this.maxPop-(this.pop.length+e.length);for(let e=0;e<t;e++){const t=this.blankGenome();this.pop.push(new b(t))}}this.mutate(),this.pop=[...e,...this.pop],this.currentPopFitness>this.lastPopFitness?this.fitnessPlatauCount=0:this.fitnessPlatauCount++,this.lastPopFitness=this.currentPopFitness;const n=this.mcp();this.pruning?(n>=this.lastMCP&&this.mcpFloorCount++,this.mcpFloorCount>=this.hyper.complexityFloorDelay&&(this.pruning=!1,this.nextPruneComplexity=n+this.hyper.complexityThreshold,this.fitnessPlatauCount=0),this.lastMCP=n):this.fitnessPlatauCount>=this.hyper.fitnessPlatauThreshold&&n>=this.nextPruneComplexity&&(this.pruning=!0)}trainFnStep(t,e=-1/0){for(let n=0;n<this.pop.length;n++){const o=t(this.pop[n]);this.pop[n].score=o,o>e&&(e=o)}return e}trainFn(t,e,n=.01,o=!0){let s=-1/0,i=0;for(;;){const h=this.trainFnStep(t,s);if(h>s){if(s=h,o){const t={};t[i]={"Best score":s},console.table(t)}if(e-s<=n)break}this.evolve(),i++}this.pop.sort(((t,e)=>e.score-t.score));return{client:this.pop[0],gen:i}}trainDataStep(t,e){let n=1/0;for(let o=0;o<this.pop.length;o++){const s=[];for(let e=0;e<t.length;e++){const[n,i]=t[e],h=this.pop[o].predict(n);if(h.length!=i.length)throw`Training data output has wrong length: ${i.length}, expected ${h.length}`;s.push([i,h])}const i=e(s);this.pop[o].score=-1*i,i<n&&(n=i)}return n}trainData(t,e=.01,n=!1,o){null==o&&(o=F[A[this.lossFn]]);let s=1/0,i=0;for(;;){const h=this.trainDataStep(t,o);if(h<s){if(s=h,n){const t={};t[i]={Loss:s},console.table(t)}if(s<=e)break}this.evolve(),i++}this.pop.sort(((t,e)=>e.score-t.score));return{client:this.pop[0],gen:i}}}return R}();
